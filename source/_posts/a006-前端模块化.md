---
title: 前端模块化
categories:
  - 前端学习
tags:
  - 模块化
date: 2022-07-11 17:51:41
index_img: https://img2.baidu.com/it/u=2633233721,1758135741&fm=253&app=138&size=w931&n=0&f=JPG&fmt=auto?sec=1657731600&t=e925da9622e91880f3ac759ac9f27c80
---

参考视频：[atguigu](https://www.bilibili.com/video/BV18s411E7Tj?spm_id_from=333.1007.top_right_bar_window_history.content.click)

---

### 概念
1. 将一个复杂的程序依据一定的规范封装成几个块，并进行组合在一起。

2. 块内部数据是私有的，只是向外部暴露一些接口与外部其它模块通信。

3. 发展史：
  >namespace(简单封装)，本质是对象，一点不安全
  >IIFE模式(匿名闭包)，利用立即执行函数，然后暴露
  >IIFE增强模式，当前模块化的基础
  
3. 优点：
    >避免命名冲突(减少命名空间污染)
    >更好的分离, 按需加载
    >更高复用性
    >高可维护性

4. 缺点：
    >需要很多的script标签
    >请求过多
    >依赖模糊
    >难以维护


### 规范
+ common.js
+ AMD规范
+ CMD规范
+ es6规范


### common.js
+ 每个文件都可当作一个模块，常用于服务器端
+ 在服务器端: 模块的加载是运行时同步加载的(node)
+ 在浏览器端: 模块需要提前编译打包处理(Browserify工具)，浏览器不认识require
    ```javascript
    /* 
    暴露模块   
    暴露的本质都是导出expors对象 
    */
    module = {
        exports:{}
    }

    /* 
    引入模块
    第三方模块：xxx为模块名(包名),放在文件最上面
    自定义模块：xxx为模块文件路径 
    */
    require(xxx)
    ```


### AMD规范 require.js
+ 专门用于浏览器端, 模块的加载是异步的
    ```javascript
    /* 
    导出
    */
    define(function() {})                               //定义没有依赖的模块
    define(['module1','module2'],function(m1,m2){})     //定义有依赖的模块

    /* 
    导入 
    */
    requirejs(['module3'],function(m3) {})
    requirejs.config({                                  //配置数组中模块加载路径：
        baseUrl:'js/'                                   //不写模块路径相对于main.js,写的话相当于根路径下js+模块路径
        paths:{
            module1:'./module1',                        //不用加js后缀，默认已经加上了
            module2:'./module2',
            module3:'./module3',
            jquery:'./jQuery 1.11.1'                    //jquery要小写且支持amd规范
        }
    })
    ```
    ```html
    <!-- 最后引入的时候使用一个script标签即可 -->
    <script data-main='main.js' src='require.js'></script> 
    ```


### CMD规范 Sea.js
+ 专门用于浏览器端, 模块的加载是异步的 
+ 模块使用时才会加载执行
    ```javascript
    /* 
    导出
    */
    define(function(require,exports,module) {
      //module.exports = xxx
      exports.a = xxx
    })

    /* 
    引入 
    */  
    define(function(exports) {
        //同步引入
        let module1 = require('./module1')               //引入最后拿到这个模块暴露的东西，但是模块上面的代码也会执行
        //异步引入
        require.async('./module2',function(module2) {
          module2.foo()
        })
        exports.b = xxx
    })
    ```
    ```html
    <!-- 使用 -->
    <script src='Sea.js'></script>                       <!-- 先引入 -->
    <script>Seajs.use('main.js')</script>                <!-- 后使用 -->
    ```


### es6规范
+ 依赖模块需要编译打包处理，很多浏览器不支持es6语法，需要编译打包成es5
    ```javascript
    /* 
    具名导出 
    */
    export value                                        //分别暴露
    export {value,value}                                //统一暴露
    //引入：
    import {名字1,名字2} from 路径    
    //或
    import * as 变量名 from 路径    
    //或
    import {名字1,名字2 as 自定义名字} from 路径          //具名导出，引入的时候必须使用对象解构赋值的方式 

    /* 
    统一导出 
    */
    export default value                                //一个模块中只能用一次

    /* 
    引入 
    */
    import 自定义名字 from 路径                          //引用第三方库，就是这种方式 
    ``` 
+ 实现(浏览器端)
  >使用Babel将es6编译成es5代码(里面有commonjs的语法)，使用browserify编译打包js
  >配置.babelrc ,rc run control运行时控制文件
